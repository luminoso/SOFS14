<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>SOFS14: sofs_ifuncs_3.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SOFS14
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">FUSE based file system</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('sofs__ifuncs__3_8h.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sofs_ifuncs_3.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Set of operations to manage data clusters: level 3 of the internal file system organization.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="sofs__inode_8h_source.html">sofs_inode.h</a>&quot;</code><br/>
</div>
<p><a href="sofs__ifuncs__3_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a982a66f513611f7f83ebfa4b4ecf1df9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a982a66f513611f7f83ebfa4b4ecf1df9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__ifuncs__3_8h.html#a982a66f513611f7f83ebfa4b4ecf1df9">GET</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a982a66f513611f7f83ebfa4b4ecf1df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">operation get the logical number of the referenced data cluster for an inode in use <br/></td></tr>
<tr class="separator:a982a66f513611f7f83ebfa4b4ecf1df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d44ee5d34e399ff293db2925d49f45b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d44ee5d34e399ff293db2925d49f45b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__ifuncs__3_8h.html#a1d44ee5d34e399ff293db2925d49f45b">ALLOC</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:a1d44ee5d34e399ff293db2925d49f45b"><td class="mdescLeft">&#160;</td><td class="mdescRight">operation allocate a new data cluster and include it into the list of references of the inode which describes the file <br/></td></tr>
<tr class="separator:a1d44ee5d34e399ff293db2925d49f45b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8e700d56e7d858108b755ad3edb52e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a8e700d56e7d858108b755ad3edb52e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__ifuncs__3_8h.html#a9a8e700d56e7d858108b755ad3edb52e">FREE</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:a9a8e700d56e7d858108b755ad3edb52e"><td class="mdescLeft">&#160;</td><td class="mdescRight">operation free the referenced data cluster <br/></td></tr>
<tr class="separator:a9a8e700d56e7d858108b755ad3edb52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a81dcdc3c04d16b8055a8a3dbf3ee2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14a81dcdc3c04d16b8055a8a3dbf3ee2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__ifuncs__3_8h.html#a14a81dcdc3c04d16b8055a8a3dbf3ee2">FREE_CLEAN</a>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:a14a81dcdc3c04d16b8055a8a3dbf3ee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">operation free the referenced data cluster and dissociate it from the inode which describes the file <br/></td></tr>
<tr class="separator:a14a81dcdc3c04d16b8055a8a3dbf3ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35321edda7ad4639415e2461e6ffee97"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35321edda7ad4639415e2461e6ffee97"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__ifuncs__3_8h.html#a35321edda7ad4639415e2461e6ffee97">CLEAN</a>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:a35321edda7ad4639415e2461e6ffee97"><td class="mdescLeft">&#160;</td><td class="mdescRight">operation dissociate the referenced data cluster from the inode which describes the file <br/></td></tr>
<tr class="separator:a35321edda7ad4639415e2461e6ffee97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8d30135caff1b0f09f870eaeda8c0a9a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__ifuncs__3_8h.html#a8d30135caff1b0f09f870eaeda8c0a9a">soReadFileCluster</a> (uint32_t nInode, uint32_t clustInd, <a class="el" href="sofs__datacluster_8h.html#a1ebe8431ffc6b05ec0ae207345855748">SODataClust</a> *buff)</td></tr>
<tr class="memdesc:a8d30135caff1b0f09f870eaeda8c0a9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a specific data cluster.  <a href="#a8d30135caff1b0f09f870eaeda8c0a9a">More...</a><br/></td></tr>
<tr class="separator:a8d30135caff1b0f09f870eaeda8c0a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf65ea1c1e3205ec4cde3da9071dde6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__ifuncs__3_8h.html#afaf65ea1c1e3205ec4cde3da9071dde6">soWriteFileCluster</a> (uint32_t nInode, uint32_t clustInd, <a class="el" href="sofs__datacluster_8h.html#a1ebe8431ffc6b05ec0ae207345855748">SODataClust</a> *buff)</td></tr>
<tr class="memdesc:afaf65ea1c1e3205ec4cde3da9071dde6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a specific data cluster.  <a href="#afaf65ea1c1e3205ec4cde3da9071dde6">More...</a><br/></td></tr>
<tr class="separator:afaf65ea1c1e3205ec4cde3da9071dde6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece666f8c869a1bc412755bd81097a17"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__ifuncs__3_8h.html#aece666f8c869a1bc412755bd81097a17">soHandleFileCluster</a> (uint32_t nInode, uint32_t clustInd, uint32_t op, uint32_t *p_outVal)</td></tr>
<tr class="memdesc:aece666f8c869a1bc412755bd81097a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle of a file data cluster.  <a href="#aece666f8c869a1bc412755bd81097a17">More...</a><br/></td></tr>
<tr class="separator:aece666f8c869a1bc412755bd81097a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944f555b10045ca40c7276ebea553136"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__ifuncs__3_8h.html#a944f555b10045ca40c7276ebea553136">soHandleFileClusters</a> (uint32_t nInode, uint32_t clustIndIn, uint32_t op)</td></tr>
<tr class="memdesc:a944f555b10045ca40c7276ebea553136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle all data clusters from the list of references starting at a given point.  <a href="#a944f555b10045ca40c7276ebea553136">More...</a><br/></td></tr>
<tr class="separator:a944f555b10045ca40c7276ebea553136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae91b85d944db1476cb2acf5050005ace"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__ifuncs__3_8h.html#ae91b85d944db1476cb2acf5050005ace">soCleanDataCluster</a> (uint32_t nInode, uint32_t nLClust)</td></tr>
<tr class="memdesc:ae91b85d944db1476cb2acf5050005ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean a data cluster from the inode describing a file which was previously deleted.  <a href="#ae91b85d944db1476cb2acf5050005ace">More...</a><br/></td></tr>
<tr class="separator:ae91b85d944db1476cb2acf5050005ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Set of operations to manage data clusters: level 3 of the internal file system organization. </p>
<p>(interface file) </p>
<pre class="fragment">  The aim is to provide an unique description of the functions that operate at this level.
</pre><p>The operations are: </p>
<ul>
<li>read a specific data cluster </li>
<li>write to a specific data cluster </li>
<li>handle a file data cluster </li>
<li>free and clean all data clusters from the list of references starting at a given point.</li>
</ul>
<dl class="section author"><dt>Author</dt><dd>Artur Carneiro Pereira September 2008 </dd>
<dd>
Miguel Oliveira e Silva September 2009 </dd>
<dd>
António Rui Borges - September 2010 / September 2011, September 2014</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>In case an error occurs, all functions return a negative value which is the symmetric of the system error or the local error that better represents the error cause. Local errors are out of the range of the system errors. </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ae91b85d944db1476cb2acf5050005ace"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soCleanDataCluster </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nInode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nLClust</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clean a data cluster from the inode describing a file which was previously deleted. </p>
<p>The inode is supposed to be free in the dirty state.</p>
<p>The list of references is parsed until the logical number of the data cluster is found or until the list is exhausted. If found, the data cluster (and all data clusters in its dependency, if it belongs to the auxiliary data structure that entails the list of single indirect or double indirect references) is cleaned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nInode</td><td>number of the inode associated to the data cluster </td></tr>
    <tr><td class="paramname">nLClust</td><td>logical number of the data cluster</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the <em>inode number</em> or the <em>logical cluster number</em> are out of range </dd>
<dd>
-<code>EFDININVAL</code>, if the free inode in the dirty state is inconsistent </dd>
<dd>
-<code>ELDCININVAL</code>, if the list of data cluster references belonging to an inode is inconsistent </dd>
<dd>
-<code>EDCINVAL</code>, if the data cluster header is inconsistent </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails reading or writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="aece666f8c869a1bc412755bd81097a17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soHandleFileCluster </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nInode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clustInd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>p_outVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle of a file data cluster. </p>
<p>The file (a regular file, a directory or a symlink) is described by the inode it is associated to.</p>
<p>Several operations are available and can be applied to the file data cluster whose logical number is given.</p>
<p>The list of valid operations is</p>
<ul>
<li>GET: get the logical number of the referenced data cluster for an inode in use </li>
<li>ALLOC: allocate a new data cluster and associate it to the inode which describes the file </li>
<li>FREE: free the referenced data cluster </li>
<li>FREE_CLEAN: free the referenced data cluster and dissociate it from the inode which describes the file </li>
<li>CLEAN: dissociate the referenced data cluster from the inode which describes the file.</li>
</ul>
<p>Depending on the operation, the field <em>clucount</em> and the lists of direct references, single indirect references and double indirect references to data clusters of the inode associated to the file are updated.</p>
<p>Thus, the inode must be in use and belong to one of the legal file types for the operations GET, ALLOC, FREE and FREE_CLEAN and must be free in the dirty state for the operation CLEAN.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nInode</td><td>number of the inode associated to the file </td></tr>
    <tr><td class="paramname">clustInd</td><td>index to the list of direct references belonging to the inode which is referred </td></tr>
    <tr><td class="paramname">op</td><td>operation to be performed (GET, ALLOC, FREE, FREE AND CLEAN, CLEAN) </td></tr>
    <tr><td class="paramname">p_outVal</td><td>pointer to a location where the logical number of the data cluster is to be stored (GET / ALLOC); in the other cases (FREE / FREE AND CLEAN / CLEAN) it is not used (in these cases, it should be set to <code>NULL</code>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the <em>inode number</em> or the <em>index to the list of direct references</em> are out of range or the requested operation is invalid or the <em>pointer to outVal</em> is <code>NULL</code> when it should not be (GET / ALLOC) </dd>
<dd>
-<code>EIUININVAL</code>, if the inode in use is inconsistent </dd>
<dd>
-<code>EFDININVAL</code>, if the free inode in the dirty state is inconsistent </dd>
<dd>
-<code>ELDCININVAL</code>, if the list of data cluster references belonging to an inode is inconsistent </dd>
<dd>
-<code>EDCINVAL</code>, if the data cluster header is inconsistent </dd>
<dd>
-<code>EDCARDYIL</code>, if the referenced data cluster is already in the list of direct references (ALLOC) </dd>
<dd>
-<code>EDCNOTIL</code>, if the referenced data cluster is not in the list of direct references (FREE / FREE AND CLEAN / CLEAN) </dd>
<dd>
-<code>EWGINODENB</code>, if the <em>inode number</em> in the data cluster <code>status</code> field is different from the provided <em>inode number</em> (ALLOC / FREE AND CLEAN / CLEAN) </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails reading or writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a944f555b10045ca40c7276ebea553136"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soHandleFileClusters </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nInode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clustIndIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle all data clusters from the list of references starting at a given point. </p>
<p>The file (a regular file, a directory or a symlink) is described by the inode it is associated to.</p>
<p>Several operations are available and can be applied to the file data clusters starting from the index to the list of direct references which is given.</p>
<p>The list of valid operations is</p>
<ul>
<li>FREE: free all data clusters starting from the referenced data cluster </li>
<li>FREE_CLEAN: free all data clusters starting from the referenced data cluster and dissociate them from the inode which describes the file </li>
<li>CLEAN: dissociate all data clusters starting from the referenced data cluster from the inode which describes the file.</li>
</ul>
<p>Depending on the operation, the field <em>clucount</em> and the lists of direct references, single indirect references and double indirect references to data clusters of the inode associated to the file are updated.</p>
<p>Thus, the inode must be in use and belong to one of the legal file types for the operations FREE and FREE_CLEAN and must be free in the dirty state for the operation CLEAN.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nInode</td><td>number of the inode associated to the file </td></tr>
    <tr><td class="paramname">clustIndIn</td><td>index to the list of direct references belonging to the inode which is referred (it contains the index of the first data cluster to be processed) </td></tr>
    <tr><td class="paramname">op</td><td>operation to be performed (FREE, FREE AND CLEAN, CLEAN)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the <em>inode number</em> or the <em>index to the list of direct references</em> are out of range or the requested operation is invalid </dd>
<dd>
-<code>EIUININVAL</code>, if the inode in use is inconsistent </dd>
<dd>
-<code>EFDININVAL</code>, if the free inode in the dirty state is inconsistent </dd>
<dd>
-<code>ELDCININVAL</code>, if the list of data cluster references belonging to an inode is inconsistent </dd>
<dd>
-<code>EDCINVAL</code>, if the data cluster header is inconsistent </dd>
<dd>
-<code>EWGINODENB</code>, if the <em>inode number</em> in the data cluster <code>status</code> field is different from the provided <em>inode number</em> (FREE AND CLEAN / CLEAN) </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails reading or writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a8d30135caff1b0f09f870eaeda8c0a9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soReadFileCluster </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nInode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clustInd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sofs__datacluster_8h.html#a1ebe8431ffc6b05ec0ae207345855748">SODataClust</a> *&#160;</td>
          <td class="paramname"><em>buff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a specific data cluster. </p>
<p>Data is read from a specific data cluster which is supposed to belong to an inode associated to a file (a regular file, a directory or a symbolic link). Thus, the inode must be in use and belong to one of the legal file types.</p>
<p>If the cluster has not been allocated yet, the returned data will consist of a cluster whose byte stream contents is filled with the character null (ascii code 0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nInode</td><td>number of the inode associated to the file </td></tr>
    <tr><td class="paramname">clustInd</td><td>index to the list of direct references belonging to the inode where data is to be read from </td></tr>
    <tr><td class="paramname">buff</td><td>pointer to the buffer where data must be read into</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the <em>inode number</em> or the <em>index to the list of direct references</em> are out of range or the <em>pointer to the buffer area</em> is <code>NULL</code> </dd>
<dd>
-<code>EIUININVAL</code>, if the inode in use is inconsistent </dd>
<dd>
-<code>ELDCININVAL</code>, if the list of data cluster references belonging to an inode is inconsistent </dd>
<dd>
-<code>EDCINVAL</code>, if the data cluster header is inconsistent </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails reading or writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="afaf65ea1c1e3205ec4cde3da9071dde6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soWriteFileCluster </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nInode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clustInd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sofs__datacluster_8h.html#a1ebe8431ffc6b05ec0ae207345855748">SODataClust</a> *&#160;</td>
          <td class="paramname"><em>buff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a specific data cluster. </p>
<p>Data is written into a specific data cluster which is supposed to belong to an inode associated to a file (a regular file, a directory or a symbolic link). Thus, the inode must be in use and belong to one of the legal file types.</p>
<p>If the cluster has not been allocated yet, it will be allocated now so that data can be stored there.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nInode</td><td>number of the inode associated to the file </td></tr>
    <tr><td class="paramname">clustInd</td><td>index to the list of direct references belonging to the inode where data is to be written into </td></tr>
    <tr><td class="paramname">buff</td><td>pointer to the buffer where data must be written from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the <em>inode number</em> or the <em>index to the list of direct references</em> are out of range or the <em>pointer to the buffer area</em> is <code>NULL</code> </dd>
<dd>
-<code>EIUININVAL</code>, if the inode in use is inconsistent </dd>
<dd>
-<code>ELDCININVAL</code>, if the list of data cluster references belonging to an inode is inconsistent </dd>
<dd>
-<code>EDCINVAL</code>, if the data cluster header is inconsistent </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails reading or writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_41b98d4f55b8bea9fa3fea214b895971.html">sofs14</a></li><li class="navelem"><a class="el" href="sofs__ifuncs__3_8h.html">sofs_ifuncs_3.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
